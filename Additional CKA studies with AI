This is in addition to the KodeKloud course for CKA
12 day structure. posted when completed for review.

Day 1: Kubernetes Fundamentals

Goals for Today
	1.	Understand Kubernetes architecture and core components.
	2.	Practice essential kubectl commands.
	3.	Create, inspect, and delete pods using YAML manifests.

Step 1: Set Up Your Environment

Choose a Kubernetes setup:
	â€¢	Option 1: Use minikube.

minikube start


	â€¢	Option 2: Use kind (Kubernetes in Docker).

kind create cluster --name cka-cluster


	â€¢	Confirm the cluster is running:

kubectl get nodes

Step 2: Learn Kubernetes Architecture

Core Components:
	â€¢	Master Node Components: API server, etcd, scheduler, controller-manager
	â€¢	Worker Node Components: kubelet, kube-proxy

Spend 20-30 minutes reviewing the official documentation:
Kubernetes Components

Step 3: Practice kubectl Basics
	1.	List all nodes:

kubectl get nodes


	2.	View cluster info:

kubectl cluster-info


	3.	Inspect namespaces:

kubectl get namespaces


	4.	Explore pods (even if none exist yet):

kubectl get pods --all-namespaces

Step 4: Create Your First Pod
	1.	Write a Pod YAML Manifest:
Save the following YAML file as nginx-pod.yaml:

apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: web
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80


	2.	Apply the Manifest:

kubectl apply -f nginx-pod.yaml


	3.	Verify the Pod is Running:

kubectl get pods
kubectl describe pod nginx


	4.	Access the Pod Logs:

kubectl logs nginx

Step 5: Clean Up
	1.	Delete the Pod:

kubectl delete -f nginx-pod.yaml


	2.	Confirm deletion:

kubectl get pods

Day 1 Checklist

âœ… Cluster is up and running.
âœ… Practiced kubectl basics.
âœ… Created, inspected, and deleted a Pod using a YAML manifest.

Let me know how it goes or if you encounter any issues!

--------

Day 2: Workloads and Scheduling

Goals for Today
	1.	Understand and work with ReplicaSets, Deployments, and DaemonSets.
	2.	Learn how to use node affinity and taints/tolerations for scheduling.
	3.	Practice scaling workloads.

Step 1: ReplicaSets
	1.	Create a ReplicaSet YAML Manifest:
Save the following YAML file as nginx-replicaset.yaml:

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80


	2.	Apply the ReplicaSet:

kubectl apply -f nginx-replicaset.yaml


	3.	Verify ReplicaSet Status:

kubectl get replicaset
kubectl get pods


	4.	Scale the ReplicaSet:

kubectl scale replicaset nginx-replicaset --replicas=5
kubectl get pods


	5.	Clean Up:

kubectl delete -f nginx-replicaset.yaml

Step 2: Deployments
	1.	Create a Deployment YAML Manifest:
Save the following YAML file as nginx-deployment.yaml:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80


	2.	Apply the Deployment:

kubectl apply -f nginx-deployment.yaml


	3.	Update the Deployment:
Update the nginx-deployment.yaml file to use nginx:1.23.2 and apply the changes:

kubectl apply -f nginx-deployment.yaml
kubectl rollout status deployment/nginx-deployment


	4.	Rollback the Deployment:

kubectl rollout undo deployment/nginx-deployment
kubectl describe deployment nginx-deployment


	5.	Clean Up:

kubectl delete -f nginx-deployment.yaml

Step 3: DaemonSets
	1.	Create a DaemonSet YAML Manifest:
Save the following YAML file as nginx-daemonset.yaml:

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: nginx-daemonset
spec:
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80


	2.	Apply the DaemonSet:

kubectl apply -f nginx-daemonset.yaml
kubectl get pods -o wide


	3.	Clean Up:

kubectl delete -f nginx-daemonset.yaml

Step 4: Node Affinity
	1.	Add a Label to a Node:

kubectl label node <node-name> environment=production


	2.	Create a Pod with Node Affinity:
Save the following YAML as nginx-affinity.yaml:

apiVersion: v1
kind: Pod
metadata:
  name: nginx-affinity
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: environment
            operator: In
            values:
            - production
  containers:
  - name: nginx
    image: nginx:latest


	3.	Apply and Verify:

kubectl apply -f nginx-affinity.yaml
kubectl get pods -o wide


	4.	Clean Up:

kubectl delete -f nginx-affinity.yaml
kubectl label node <node-name> environment-

Step 5: Taints and Tolerations
	1.	Add a Taint to a Node:

kubectl taint nodes <node-name> key=value:NoSchedule


	2.	Create a Pod with a Toleration:
Save the following YAML as nginx-toleration.yaml:

apiVersion: v1
kind: Pod
metadata:
  name: nginx-toleration
spec:
  tolerations:
  - key: "key"
    operator: "Equal"
    value: "value"
    effect: "NoSchedule"
  containers:
  - name: nginx
    image: nginx:latest


	3.	Apply and Verify:

kubectl apply -f nginx-toleration.yaml
kubectl get pods -o wide


	4.	Clean Up:

kubectl delete -f nginx-toleration.yaml
kubectl taint nodes <node-name> key-

Day 2 Checklist

âœ… Created and managed ReplicaSets, Deployments, and DaemonSets.
âœ… Practiced scaling and updating workloads.
âœ… Worked with node affinity and taints/tolerations.

Let me know how it goes! ðŸš€

------------

Day 3: Services, Networking, and ConfigMaps

Goals for Today
	1.	Understand and work with Kubernetes Services (ClusterIP, NodePort, and LoadBalancer).
	2.	Explore how to use ConfigMaps to manage application configuration.
	3.	Practice debugging and troubleshooting pods and services.

Step 1: Expose a Deployment Using a Service
	1.	Create a Deployment:
Save the following YAML as nginx-deployment-service.yaml:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80

Apply it:

kubectl apply -f nginx-deployment-service.yaml


	2.	Create a ClusterIP Service:
Save the following YAML as nginx-clusterip.yaml:

apiVersion: v1
kind: Service
metadata:
  name: nginx-clusterip
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP

Apply it:

kubectl apply -f nginx-clusterip.yaml


	3.	Verify the Service:

kubectl get svc
kubectl describe svc nginx-clusterip
kubectl get endpoints


	4.	Access the Service (Inside the Cluster):
Use a debug pod:

kubectl run debug-pod --rm -it --image=busybox -- /bin/sh
wget -qO- http://nginx-clusterip


	5.	Clean Up:

kubectl delete -f nginx-deployment-service.yaml
kubectl delete -f nginx-clusterip.yaml

Step 2: NodePort Service
	1.	Modify the Service Type:
Save the following YAML as nginx-nodeport.yaml:

apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    nodePort: 30007
  type: NodePort

Apply it:

kubectl apply -f nginx-nodeport.yaml


	2.	Access the Service:
Find your cluster nodeâ€™s IP and access the service:

kubectl get nodes -o wide
curl http://<node-ip>:30007


	3.	Clean Up:

kubectl delete -f nginx-nodeport.yaml

Step 3: ConfigMaps
	1.	Create a ConfigMap:

kubectl create configmap nginx-config --from-literal=env=production
kubectl get configmaps
kubectl describe configmap nginx-config


	2.	Use ConfigMap in a Pod:
Save the following YAML as nginx-configmap-pod.yaml:

apiVersion: v1
kind: Pod
metadata:
  name: nginx-configmap
spec:
  containers:
  - name: nginx
    image: nginx:latest
    env:
    - name: ENV
      valueFrom:
        configMapKeyRef:
          name: nginx-config
          key: env

Apply it:

kubectl apply -f nginx-configmap-pod.yaml
kubectl exec -it nginx-configmap -- env | grep ENV


	3.	Clean Up:

kubectl delete -f nginx-configmap-pod.yaml
kubectl delete configmap nginx-config

Step 4: Debugging Pods and Services
	1.	Troubleshooting Pods:
Create a faulty pod:

apiVersion: v1
kind: Pod
metadata:
  name: faulty-pod
spec:
  containers:
  - name: nginx
    image: nginx:nonexistent

Apply it:

kubectl apply -f faulty-pod.yaml
kubectl get pods
kubectl describe pod faulty-pod
kubectl logs faulty-pod


	2.	Clean Up:

kubectl delete -f faulty-pod.yaml

Step 5: Practice with LoadBalancer Service (Optional)

If your environment supports LoadBalancer (e.g., cloud providers or minikube with add-ons):
	1.	Modify the service:

apiVersion: v1
kind: Service
metadata:
  name: nginx-loadbalancer
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: LoadBalancer

Apply it and verify:

kubectl apply -f nginx-loadbalancer.yaml
kubectl get svc


	2.	Clean Up:

kubectl delete -f nginx-loadbalancer.yaml

Day 3 Checklist

âœ… Created and managed ClusterIP, NodePort, and LoadBalancer Services.
âœ… Practiced ConfigMaps for managing configuration.
âœ… Debugged a faulty pod.

Let me know how you did and if youâ€™re ready for Day 4!

--------------------
